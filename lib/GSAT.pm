package GSAT;
#updated at Nov 22th, 2022: fixed a bug related to the params in example.conf
#updated at Feb 13, 2025: fixed several bugs and provided some new fetures.
#updated at Feb 27, 2025: update params for gSimp module
#updated at Jul 24, 2025: update params for gSimp module
#updated at Aug 4, 2025: enable auto-estimation of depth-related params for gSimp module
#updated at Dec 2, 2025: optimalized the RAM usage of the GSAT pipelines
#updated at Dec 5, 2025: more options for estimating the depth-related params
#updated at Dec 9, 2025: the options for pathCorr funtion are changed
#updated at Dec 19, 2025: enable the mmgStat function
#updated at Dec 23, 2025: enable the graphMatrix function

=pod

=head1 NAME

GSAT - Graph-based Sequence Assembly Toolkit

=head1 SYNOPSIS

    gsat <command> [options]

    Commands:
    -- Functions
       graphFilt            filter the assembly graph with different params
       graphMap             conduct graph mapping to detect mapped paths in a graph for query sequence
       graphCorr            correct the sequences in a graph by using long reads. HIFI reads is recommanded.
       graphSimplify        simplify the graph based on supported mapped paths of long reads.
       rmOverlap            remove the overlaping regions from a graph.
       graphClip            clip the graph based on the supports of long reads.
       graphMerge           merge all possible nodes.
       graphStat            generate a summary of assembled graphs.
       graphMatrix          generate a distance matrix across different graphs.

    -- Pipelines
       graphShort           generate a Organelle Graph from a raw graph of de novo assembly
       graphLong            generate a Mitochondrial Rough Graph from a OG
       graphSimplification  generate a Mitochondrial Rough Master Graph from a MRG
       graphCorrection      generate a Mitochondrial Master Graph from a MRMG

    -- Information
       help                 print a brief help information
       man                  print a complete help document
       version              print the version information

=head1 VERSION

GSAT version 1.60 (2026-02-24)

=head1 USAGE

 Usage

=head1 graphFilt

    Usage:   gsat graphFilt [options]

    Global params:
    -pt|-p             filter the plastid-specific contigs. Not compatiable with -nuc.*
    -nuc|-n            filter the nuclear-specific contigs. Not compatiable with -pt.*
    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of the output files.

    Pt-filtering params:
    -mapFile [str]     the mapped paths file generated by graph mapping.*
    -minPathNo [int]   the min number of supported paths for remaining a link.*
    -minEnd [int]      the end contig with a length shorter than this value will be filtered.*
    -rmBubbPt          remove the pt-like contig from a bubble. Be careful with this option. [off]

    Nuc-filtering params:
    -minDep1 [int]     the min depth allowed for a remained contig longer than 500bp.*
    -minDep2 [int]     the min depth allowed for a remained contig longer than 1000bp.*
    -rmSep             remove the seperate ctg with no link to others or not. [off]

    Note: the * denoted a required option. 

=head1 graphMap

    Usage:   gsat graphMap [options]

    -align|-a                 Conduct graph mapping of reads vs the graph (require -r and -g options). [off]*
    -readFile|-r [str]        A Pacbio / Nanopore read file in fasta format. NOT available if -a is off.*
    -gfaFile|-g [str]         The input graph file.*
    -blast7File|-b [str]      Calculate the mapped paths from a blastn result file. NOT available if -a|-p is applied.*
    -pafFile|-p [str]         Calculate the mapped paths from a minimap2 result file. NOT available if -a|-b is applied.*
    -minRead [int]            The min length (bp) of selected reads. [1000]
    -maxOffset1 [int]         The max offset between the ends of contigs in alignments, regarding the overlaps of contigs. [10]
                              The real range of offset is from 1-K-offset to 1-K+offset. Not compatible with --maxOffset2.
    -maxOffset2 [int]         The max offset between the ends of contigs in alignments, ignoring the overlaps of contigs. [off]
                              The real range of offset is from 0-offset to 0+offset. Not compatible with --maxOffset1.
    -maxCombDis [int]         The max distances allowed for combining two alignments. [15]
    -maxEdgeSize1 [int]       The max gap size allowed for the alignment at the edge of reads. [60]
    -maxEdgeSize2 [int]       The max gap size allowed for the alignment at the edge of contigs. [10]
    -maxBounderRatio [float]  The max ratio allowed for the bounder size which covered the full length of a contig. [0.1]
    -maxIdenGap [float]       The max difference allowed for remained an alternative alignment (path)
                              when compared with to the identity of the best alignment (path). [1]
                              Caution: It is still a beta method that is not recommanded to use until now.
    -minIden [float]          The min identity allowed for use an alignment (in b7 and paf file). [0.85]
    -minCovofRead [float]     The min coverage allowed in the alignment for use a read (in b7 and paf file). [0.9]
    -minCovbyPath [float]     The min coverage to the read allowed for outputting a path. [0.9]
    -out|-o [str]             The name prefix of output files.
    -strictBub                Bubbles were retained only when all members were mapped to the read with exactly the same
                              start and end positions. [on]
    -depth|-d                 Calculate the depth of passed reads on the contigs. [off]
    -calDepth|-cd             Calculate the depth (like -d) directly from previous results (require -o and -g options). [off]
    -filterPaths|-f           Further filtering the previous results when apply the -cd option. [off]
                              However, only -minRead and -minCovbyPath options are available for now.
    -minimap2 [str]           Use minimap2 to map reads to the long contigs, rather than use blastn. [off]
                              The read type should be specified here such as hifi, clr, ont.

    Note: the * denoted a required option. 

=head1 graphCorr

    Usage:   gsat graphCorr [options]

    -readFile|-r [str]       A Pacbio / Nanopore read file in fasta format.* 
    -gfaFile|-g  [str]       The file of genome assembly in gfa format.\n";*
    -pathFile|-p [str]       The mapped paths file generated by GraphMap module (module version >= 1.51).*
    -minReadProp|-m [float]  The min proportion of supported reads to confirm a base correction.
    -out|-o [str]            The name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 graphSimplify

    Usage:   gsat graphSimplify [options]

    -gfaFile|-g [str]      the input graph file.*
    -mapFile [str]         the mapped paths file generated by graph mapping.*
    -minPathNo [int]       the min number of supported paths for remaining a link.*
    -minEnd [int]          the end contig with a length shorter than this value will be filtered.
    -minAddPathNo [int]    the min number of supported paths for adding a link. [20]
    -corrPath [str]        enable path correction for all/low-depth contigs or not. [all/low/off]
    -rmLowSuppNode         remove the putative contaminant contig with low support from the long reads(require -DepFile). [off]
    -NodeDep [int:int]     The min and max depth of long reads for removing a contig (require -rmLowSuppNode). [10:30]
    -DepFile [str]         The depth file generated by grapMap function (e.g., gmap.passed.depth). 
    -out|-o [str]          the name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 rmOverlap

    Usage:   gsat rmOverlap [options]

    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of output files.

    Note: the * denoted a required option.

=head1 graphClip

    Usage:   gsat graphClip [options]

    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of output files.
    -mtReadList [str]  the file containing mt-reads, which is generated by graph mapping.*
    -b7File [str]      the b7 file generated by graph mapping.
    -pafFile [str]     the paf file generated by graph mapping.
    -minPathNum [int]  the min number of supported reads for clipping a link.
    -minNodeLen [int]  the min length of nodes after clipping.

    Note: the * denoted a required option.

=head1 graphMerge

    Usage:   gsat graphMerge [options]

    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of output files.

    Note: the * denoted a required option.

=head1 graphStat

    Usage:   gsat graphStat [options]

    -gfaFile|-g [str]  the input graph file.*
    -copyEstimate|-c   estimate the copies of repetitive contigs.
    -out|-o [str]      the name prefix of output files.

    Note: the * denoted a required option.

=head1 graphMatrix

    Usage:   gsat graphMatrix [options]

    -fileList|-f [str]     A list file containing sample name, *.mapping.paths and *.gfa for each sample in a line.*
    -contigList|-c [str]   A list file containing the names of pangenomic segments across those graphs.*
    -out|-o [str]          the name prefix of output files.

    Note: the * denoted a required option.

=head1 graphShort

    Usage:   gsat graphShort [options]

    -conf [str]        the config file.*
    -cpu [int]         number of cpu cores which could be used for the pipeline.

    Note: the * denoted a required option.

=head1 graphLong

    Usage:   gsat graphLong [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=head1 graphSimplification

    Usage:   gsat graphSimplification [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=head1 graphCorrection

    Usage:   gsat graphCorrection [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=cut

use strict;
use warnings;
use FindBin;
use File::Basename;
use Getopt::Long;
use Getopt::Long qw(GetOptionsFromArray);
use Pod::Usage;
use Pod::Find qw(pod_where);
use Storable qw(freeze thaw);
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../lib";
use lib "$FindBin::RealBin/lib";

require GSAT::graphFilterPt;
require GSAT::graphFilterNuc;
require GSAT::graphMapper;
require GSAT::graphCorrector;
require GSAT::graphSimply;
require GSAT::rmOverlap;
require GSAT::graphClip;
require GSAT::graphMerge;
require GSAT::graphStat;
require GSAT::graphMatrix;

sub gsatRun{
   our ($proc,$opt)=@_;
   if($proc =~ /^graphFilt$/i){
      my ($pt,$nuc,$gfa,$map,$outP,$minPath,$minEnd,$rmPt,$minD1,$minD2,$rmSep);
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphFilt) ])if @{$opt} == 0;
      GetOptionsFromArray($opt,
        'pt'           => \$pt,
        'nuc'          => \$nuc,
        'gfaFile=s'    => \$gfa,
        'mapFile=s'    => \$map,
        'out=s'        => \$outP,
        'minPathNo=i'  => \$minPath,
        'minEnd=i'     => \$minEnd,
        'rmBubbPt'     => \$rmPt,
        'minDep1=i'    => \$minD1,
        'minDep2=i'    => \$minD2,
        'rmSep'        => \$rmSep,
      );
      my $rstat= defined($rmPt) ? 'T':'F';
      graphFilterPt::filterPt($gfa,$map,$minPath,$minEnd,$rstat,'T',$outP) if defined($pt);
      my $rsstat= defined($rmSep) ? 'T':'F';
      graphFilterNuc::filterNuc($gfa,$minD1,$minD2,$rsstat,$outP) if defined($nuc);
   }
   elsif($proc =~ /^graphMap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphMap) ])if @{$opt} == 0;
      graphMapper::gmap($opt);#done
   }
   elsif($proc =~ /^graphCorr$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphCorr) ])if @{$opt} == 0;
      graphCorrector::grapCorr($opt);#done
   }
   elsif($proc =~ /^graphSimplify$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphSimplify) ])if @{$opt} == 0;
      my ($gfa,$map,$outP,$minPath,$minEnd,$minAddNo,$corrAll,$rm_fake,$dep_range,$dep_file);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'mapFile=s'      => \$map,
        'out=s'          => \$outP,
        'minPathNo=i'    => \$minPath,
        'minAddPathNo=i'    => \$minAddNo,
        'corrPath=s'       => \$corrAll,
        'minEnd=i'       => \$minEnd,
        'rmLowSuppNode'  => \$rm_fake,
        'NodeDep=s'      => \$dep_range,
        'DepFile=s'      => \$dep_file,
      );

      my $rf_stat=defined($rm_fake) ? 1:0;
      graphSimply::filterGraph($gfa,$map,$minPath,$minEnd,$outP,$minAddNo,$corrAll,$rf_stat,$dep_file,$dep_range);#list
   }
   elsif($proc =~ /^rmOverlap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(rmOverlap) ])if @{$opt} == 0;
      my ($gfa,$outP);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'out=s'          => \$outP,
      );
      rmOverlap::m0proc($gfa,$outP);#done
   }
   elsif($proc =~ /^graphMerge$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphMerge) ])if @{$opt} == 0;
      my ($gfa,$outP);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'out=s'          => \$outP,
      );
      graphMerge::gmerge($gfa,$outP);#done
   }
   elsif($proc =~ /^graphStat$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphStat) ])if @{$opt} == 0;
      my ($gfa,$outP,$eStat);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'out=s'          => \$outP,
        'copyEstimate'   => \$eStat,
      );
      my $es=defined($eStat) ? 1:0;
      graphStat::mmgStat($gfa,$outP,$es);#done
   }
   elsif($proc =~ /^graphMatrix$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphMatrix) ])if @{$opt} == 0;
      my ($flist,$outP,$clist);
      GetOptionsFromArray($opt,
        'fileList=s'     => \$flist,
        'out=s'          => \$outP,
        'contigList=s'   => \$clist,
      );
      graphMatrix::cmpMatrix($flist,$clist,$outP);#done
   }
   elsif($proc =~ /^graphClip$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphClip) ])if @{$opt} == 0;
      graphClip::clip_graph($opt);
   }
   elsif($proc =~ /^graphShort$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphShort) ])if @{$opt} == 0;
      pipeShort($opt);
   }
   elsif($proc =~ /^graphLong$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphLong) ])if @{$opt} == 0;
      pipeLong($opt);
   }
   elsif($proc =~ /^graphSimplification$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphSimplification) ])if @{$opt} == 0;
      pipeSim($opt);
   }
   elsif($proc =~ /^graphCorrection$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphCorrection) ])if @{$opt} == 0;
      pipeCorr($opt);
   }
   else{
      die"Error: Wrong command detected!\n";
   }
}

sub pipeShort{
   my @opts2_1=('r1','r2','maxReadLen','minDep1','minDep2');
   my @opts2_2=('rmSep');
   my @x1=('');
   my @x2=('');
   my $opts3='out';
   my $spades='spades.py';
   my $cpu=2;
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
        'cpu=i'          => \$cpu,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts2_1,\@opts2_2,\@x1,\@x2,$opts3);
   newDir($outp); 
   my @short_opt=split(/ /,$c1);
   my ($r1,$r2,$max_rlen,$minD1,$minD2,$rmSep,$ks);
   GetOptionsFromArray(\@short_opt,
        'r1=s'      => \$r1,
        'r2=s'      => \$r2,
        'maxReadLen=i'   => \$max_rlen,
        'minDep1=i'      => \$minD1,
        'minDep2=i'      => \$minD2,
        'rmSep'          => \$rmSep,
      );
   my $in_gfa=$outp.'/spades/assembly_graph_with_scaffolds.gfa';
   print "Read1: $r1 ; Read2: $r2 ";
   warn "Warning: Please note that the SPAdes is not recommended for large sequencing dataset > 5 gb. You can use a subset instead.\n" if (stat($r1))[7] > 5000000 &&  (stat($r2))[7] > 5000000;
   if($max_rlen >92 && $max_rlen <= 102){
      $ks="-k 21,33,55,71,91";
   }
   elsif($max_rlen > 147 && $max_rlen <= 152){
      $ks="-k 33,55,77,99,121";
   }
   elsif($max_rlen > 100 && $max_rlen <= 150){
      $ks="-k 21,33,55,71,99";
   }
   else{
      $ks="";
   }
   print `$spades --careful -1 $r1 -2 $r2 $ks --cov-cutoff auto -t $cpu -o $outp/spades`;
   #eval {`$spades --careful -1 $r1 -2 $r2 $ks --cov-cutoff auto -t $cpu -o $outp/spades`;};
   die "$@ \n" if $@;
   my $rsstat= defined($rmSep) ? 'T':'F';
   graphFilterNuc::filterNuc($in_gfa,$minD1,$minD2,$rsstat,$outp.'/og');
}

my @opts1_1=('readFile','gfaFile','minRead','maxOffset1','maxOffset2','maxCombDis','maxEdgeSize1','maxEdgeSize2','maxBounderRatio','maxIdenGap','minIden','minCovofRead','minCovbyPath','strictBub','minimap2');
my @opts1_2=('depth');
sub pipeLong{
   my @opts2_1=('gfaFile','minPathNo','minEnd');
   my @opts2_2=('rmBubbPt');
   my $opts3='out';
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   my @gfp_opt=split(/ /,$c2);
   run_in_subprocess('graphMapper::gmap',\@gmap_opt);
   my $pfile=$outp.'/gmap.mapping.paths';
   my ($gfa,$minPath,$minEnd,$rmPt);
   GetOptionsFromArray(\@gfp_opt,
        'gfaFile=s'    => \$gfa,
        'minPathNo=i'  => \$minPath,
        'minEnd=i'     => \$minEnd,
        'rmBubbPt'     => \$rmPt,
      );
   my $rstat= defined($rmPt) ? 'T':'F';
   graphFilterPt::filterPt($gfa,$pfile,$minPath,$minEnd,$rstat,'T',$outp.'/mrg');
}

sub pipeCorr{
   my @opts2_1=('readFile','gfaFile','minReadProp');
   my @opts2_2=('undef');
   my $opts3='out';
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   
   run_in_subprocess('graphMapper::gmap',\@gmap_opt);
   
   my $pfile=$outp.'/gmap.mapping.paths';
   my @gc_opt=((split(/ /,$c2)),'-'.$opts3,$outp.'/mmg','-pathFile',$pfile);
   graphCorrector::grapCorr(\@gc_opt);
}

sub pipeSim{
   my @opts2_1=('gfaFile','minPathNo','minEnd','minAddPathNo','NodeDep','corrPath');
   my @opts2_2=('rmLowSuppNode','autoEst');
   my $opts3='out';
   my $confile;
   my $misRatio=4;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
	     'misDepRatio=i' => \$misRatio,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   run_in_subprocess('graphMapper::gmap',\@gmap_opt);

   my $pfile=$outp.'/gmap.mapping.paths';
   my $dfile=$outp.'/gmap.passed.depth';
   my $top_dep=hist_top($dfile,25);
   my $nd50=ND50($dfile);
   my $cd50=CD50($dfile);

   my @gs_opt=split(/ /,$c2);
   my ($gfa,$minPath,$minEnd,$minAddNo,$corrAll,$rm_fake,$auto_est,$dep_range);
      GetOptionsFromArray(\@gs_opt,
        'gfaFile=s'      => \$gfa,
        'minPathNo=i'    => \$minPath,
        'minEnd=i'       => \$minEnd,
        'minAddPathNo=i'    => \$minAddNo,
        'corrPath=s'       => \$corrAll,
        'rmLowSuppNode'  => \$rm_fake,
        'autoEst'        => \$auto_est,
        'NodeDep=s'      => \$dep_range,
      );
   #my $pc_stat=defined($corrAll) ? 1:0;
   my $rf_stat=defined($rm_fake) ? 1:0;

   #估计minPathNum等参数
   if(defined($auto_est)){
      warn "Estimate the highest frequency of the depth: $top_dep | $nd50 | $cd50 \n";
      my $ratio_adj=0.25;#相对于top_depth的比例
      $minPath = int($ratio_adj * $top_dep);
      $minAddNo = $minPath;
      $dep_range = int($minPath/$misRatio).':'.$minPath;
   }
   graphSimply::filterGraph($gfa,$pfile,$minPath,$minEnd,$outp.'/mrmg',$minAddNo,$corrAll,$rf_stat,$dfile,$dep_range);
}

sub readConf{
   my ($inf,$opt1x1,$opt1x2,$opt2x1,$opt2x2,$out)=@_;
   open(CFILE,$inf) || die "Error: Cannot open the config file! \n";
   my @opt1;
   my @opt2;
   foreach (<CFILE>){
      chomp;
      next if /^#|^\s|^$/;
      my ($n,$v)=split(/\s+/);
      push @opt1,$n;
      push @opt2,$v;
   }
   close CFILE;

   my $used1='^'.join('$|^',@{$opt1x1}).'$';
   my $used2='^'.join('$|^',@{$opt2x1}).'$';
   my @opt_a1=map {'-'.$opt1[$_].' '.$opt2[$_]} (grep {$opt2[$_] ne 'off' && $opt1[$_]=~/$used1/} 0..$#opt1);
   my @opt_a2=map {'-'.$opt1[$_].' '.$opt2[$_]} (grep {$opt2[$_] ne 'off' && $opt1[$_]=~/$used2/} 0..$#opt1);
   my ($optsv3)=map {$opt2[$_]} (grep {$opt1[$_]=~/$out/} 0..$#opt1);
   $optsv3 = 'gsat' if length($optsv3) < 1;
   my $usedu1='^'.join('$|^',@{$opt1x2}).'$';
   my $usedu2='^'.join('$|^',@{$opt2x2}).'$';
   my @opt_b1=map {'-'.$opt1[$_]} (grep {$opt1[$_]=~/$usedu1/ && $opt2[$_] eq 'on'} 0..$#opt1);
   my @opt_b2=map {'-'.$opt1[$_]} (grep {$opt1[$_]=~/$usedu2/ && $opt2[$_] eq 'on'} 0..$#opt1);

   return(join(' ',(@opt_a1,@opt_b1)),join(' ',(@opt_a2,@opt_b2)),$optsv3);
}

sub newDir{
   my $outp=shift @_;
   if(-d $outp){
      die"Error: the specified target dir is existed: $outp \n";
   }
   else{
      mkdir($outp) || die "Error: Cannot create the target dir: $outp \n";
   }
}

sub ND50{
   my $df=shift;
   open(IN_DF,$df) || die $!;
   my @deps=map {chomp;(split(/\t/))[2]} <IN_DF>;
   close IN_DF;
   return median(@deps);
}

sub CD50{
   my $df=shift;
   my %deps;
   open(IN_DF,$df) || die $!;
   foreach my $l(<IN_DF>){
      chomp($l);
      my ($c,undef,$d)=split(/\t/,$l);
      if(exists $deps{$c}){
         push @{$deps{$c}},$d;
      }
      else{
         $deps{$c}=[$d];
      }
   }
   close IN_DF;

   my @cs_dep = map {median(@{$deps{$_}})} keys %deps;
   return median(@cs_dep);
}

sub median{
   my @sorted=sort {$b <=> $a} @_;
   my $mid_n=int((@sorted + 1)/2);
   return $sorted[$mid_n];
}

sub hist_top{
   my $df=shift;
   my $win=shift;
   open(IN_DF,$df) || die $!;
   my @deps=map {(split(/\t/))[2]} <IN_DF>;
   close IN_DF;
   my @freq;
   foreach my $i(@deps){
      my $j=int($i/$win);
      $freq[$j] ++;
   }
   my $max=0;
   my $max_n=0;
   my $fq_id=0;
   foreach my $k(@freq){
      $fq_id ++;
      $k = defined $k ? $k : 0;
      if($max < $k){
         $max = $k;
         $max_n = $fq_id;
      }
   }
   return $max_n * $win;
}

sub run_in_subprocess {
    my ($func_name, $arg_ref) = @_;

    my ($pkg, $func) = split /::/, $func_name;
    unless ($pkg && $func) {
        die "Fatal error in the code: $func_name";
        return 0;
    }

    pipe my $reader, my $writer or die "Fatal error: The pipe cannot be created: $!";

    my $pid = fork();
    unless (defined $pid) {
        die "Fatal error: The subprocess cannot be launched: $!";
    }

    if ($pid) {
        close $writer;  # 关闭写入端

        my $serialized_data = do { local $/; <$reader> };
        close $reader;

        waitpid($pid, 0);

        if ($serialized_data) {
            my $result = thaw($serialized_data);
            print $result if defined $result;
            return 1;
        } else {
            return 0;
        }
    } else {
        close $reader;  # 关闭读取端

        eval {
	         no strict 'refs';
            my $func_ref = \&{$func_name};
            $func_ref->($arg_ref);
        };

        if ($@) {
	         warn $@;
            close $writer;
            exit 1;
        }

        close $writer;

        exit 0;  # 子进程退出，释放所有内存
    }
}

1;